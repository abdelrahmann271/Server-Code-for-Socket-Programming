http://localhost:4000/


#include <iostream>
#include <winsock.h>
#include <bits/stdc++.h>
#include <stdlib.h>

#define MYPORT 4000
#define AF_INET 2
#define BACKLOG 10 // how many pending connections queue will hold
#define DEST_IP "10.12.110.57"
#define DEST_PORT 23


using namespace std;
//struct sockaddr {
//    unsigned short sa_family; // address family, AF_xxx
//    char sa_data[14]; // 14 bytes of protocol address
//};

//struct sockaddr_in {
//    short int sin_family; // Address family
//    unsigned short int sin_port; // Port number
//    struct in_addr sin_addr; // Internet address
//    unsigned char sin_zero[8]; // Same size as struct sockaddr
//};

// //Internet address (a structure for historical reasons)
//struct in_addr {
//    unsigned long s_addr;
//};

int main() {

    WSAData wsaData;
    if (WSAStartup(MAKEWORD(1, 1), &wsaData) != 0) {
        fprintf(stderr, "WSAStartup failed.\n");
        exit(1);
    }

//    while true:
//    do Listen for connections
//    Accept new connection from incoming client and delegate it to worker thread/process
//    Parse HTTP/1.1 request and determine the command (GET or POST)
//    Determine if target file exists (in case of GET) and return error otherwise
//    Transmit contents of file (reads from the file and writes on the socket) (in case of GET)
//    Wait for new requests (persistent connection)
//    Close if connection timed out
//    end while

//    uint32_t inval = 0xAABBCCDD;
//    cout<<hex<<inval<<"\n";
//    uint32_t outval = htonl(inval);
//    cout<<hex<<outval<<"\n";


//    struct sockaddr_in my_addr;
//    my_addr.sin_addr.s_addr = inet_addr("255.255.255.255");
//    //Notice that inet_addr() returns the address in Network Byte Order already
//    cout<< my_addr.sin_addr.s_addr<<"\n";
//
////    struct sockaddr_in my_addr;
//    my_addr.sin_family = AF_INET; // host byte order
//    my_addr.sin_port = htons(80); // short, network byte order
//
//    //memset(&(my_addr.sin_zero), ’\0’, 8); // zero the rest of the struct
//    cout<<    inet_ntoa(my_addr.sin_addr) <<"\n";

//    int fs = socket( AF_INET,SOCK_STREAM,0);
//    cout<<fs<<"\n";


//        int sockfd;
//        struct sockaddr_in my_addr;
//        sockfd = socket(AF_INET, SOCK_STREAM, 0); // do some error checking!
//        my_addr.sin_family = AF_INET; // host byte order
//        my_addr.sin_port = htons(MYPORT); // short, network byte order
//        my_addr.sin_addr.s_addr = inet_addr("10.12.110.57");
//        memset(&(my_addr.sin_zero), '\0', 8); // zero the rest of the struct
//        // don’t forget your error checking for bind():
//        bind(sockfd, (struct sockaddr *)&my_addr, sizeof(struct sockaddr));
//        //cout<<INADDR_ANY;

//    int sockfd;
//    struct sockaddr_in dest_addr; // will hold the destination addr
//    sockfd = socket(AF_INET, SOCK_STREAM, 0); // do some error checking!
//    dest_addr.sin_family = AF_INET; // host byte order
//    dest_addr.sin_port = htons(DEST_PORT); // short, network byte order
//    dest_addr.sin_addr.s_addr = inet_addr(DEST_IP);
//    memset(&(dest_addr.sin_zero), '\0', 8); // zero the rest of the struct
//// don’t forget to error check the connect()!
//    cout<<connect(sockfd, (struct sockaddr *)&dest_addr, sizeof(struct sockaddr));

//    int sockfd, new_fd; // listen on sock_fd, new connection on new_fd
//    struct sockaddr_in my_addr; // my address information
//    struct sockaddr_in their_addr; // connector’s address information
//    int sin_size;
//    sockfd = socket(AF_INET, SOCK_STREAM, 0); // do some error checking!
//    my_addr.sin_family = AF_INET; // host byte order
//    my_addr.sin_port = htons(MYPORT); // short, network byte order
//    my_addr.sin_addr.s_addr = INADDR_ANY; // auto-fill with my IP
//    memset(&(my_addr.sin_zero), '\0', 8); // zero the rest of the struct
//// don’t forget your error checking for these calls:
//    bind(sockfd, (struct sockaddr *)&my_addr, sizeof(struct sockaddr));
//    listen(sockfd, BACKLOG);
//    sin_size = sizeof(struct sockaddr_in);
//    //new_fd = accept(sockfd, &their_addr, &sin_size);
//    new_fd = accept(sockfd, reinterpret_cast<sockaddr *>(&their_addr), &sin_size);

    int sockfd, new_fd; // listen on sock_fd, new connection on new_fd
    struct sockaddr_in my_addr; // my address information

    int sin_size;
    sockfd = socket(AF_INET, SOCK_STREAM, 0); // do some error checking!
    if(sockfd == -1)
        perror("socket() error" );
    my_addr.sin_family = AF_INET; // host byte order
    my_addr.sin_port = htons(MYPORT); // short, network byte order
    my_addr.sin_addr.s_addr = inet_addr("127.0.0.1"); // auto-fill with my IP
    memset(&(my_addr.sin_zero), '\0', 8); // zero the rest of the struct
// don’t forget your error checking for these calls:
    if(bind(sockfd, (struct sockaddr *)&my_addr, sizeof(struct sockaddr)) == -1){
        perror("bind() error");
    }

    sin_size = sizeof(struct sockaddr_in);
//    cout<<sockfd<<"\n";
//    cout<<INADDR_ANY<<"\n";
//    cout<<my_addr.sin_addr.s_addr<<"\n";



    while(true){
        //do Listen for connections
        if(listen(sockfd, BACKLOG) == -1){
            perror("listen() error");
        }

        //cout<<"\ndebug1"<<"\n";
       // Accept new connection from incoming client and delegate it to worker thread/
        struct sockaddr_in their_addr; // connector’s address information
        //cout<<"debug2"<<"\n";
        //It is stuck here until a request come!

        new_fd = accept(sockfd, reinterpret_cast<sockaddr *>(&their_addr), &sin_size);
        //cout<<"debug3"<<"\n";

        char buf[8196];
//        if( recv(new_fd, buf, 2000, 0) == -1 ){
//            perror("recv");
//        }
        int c = recv(new_fd, buf, 8196, 0);
        for(int i = 0;i < c;i++) std::cout << buf[i];
        //int number_of_bytes_receieved = recv(new_fd, buf, 255, 0);
        //cout<<"debug4"<<"\n";
        //cout<<"number_of_bytes_receieved\n";
        //cout<<number_of_bytes_receieved<<"\n";
        //cout<<"Buffer\n";
        //cout<<*buf<<"\n";
        //printf(buf);
//        for(int i = 0 ; i < number_of_bytes_receieved ; i++){
//            cout<<buf[i];
//        }
        //cout<<"\neh";
        //Parse HTTP/1.1 request and determine the command (GET or POST)
        //Determine if target file exists (in case of GET) and return error otherwise
        //Transmit contents of file (reads from the file and writes on the socket) (in case of GET)
        //      send()
        //Wait for new requests (persistent connection)
        //      wait()
        //Close if connection timed out
        // close or shut Down
    }

    return 0;
}
